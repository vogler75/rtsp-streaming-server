<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTSP Server Dashboard</title>
    <link rel="icon" type="image/x-icon" href="#" id="favicon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .refresh-section {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        .admin-section {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        button.admin-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.add-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button.config-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        button.delete-btn {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .btn-start {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        select, input[type="text"], input[type="number"], input[type="password"] {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 14px;
        }

        select option {
            background: #2a5298;
            color: white;
        }

        .server-status {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .status-item {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
        }

        .status-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .cameras-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .camera-tile {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .camera-tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .camera-header {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .camera-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .camera-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4caf50;
            /* Disabled animation to reduce CPU usage */
            /* animation: pulse 2s infinite; */
            box-shadow: 0 0 4px rgba(76, 175, 80, 0.5);
        }

        .status-indicator.offline {
            background: #f44336;
            animation: none;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        .camera-preview {
            position: relative;
            height: 200px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .camera-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .camera-preview .no-preview {
            color: #666;
            font-size: 14px;
        }

        .preview-controls {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 8px;
            border-radius: 4px;
        }

        .stream-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .stream-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .camera-info {
            padding: 15px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .info-label {
            opacity: 0.8;
        }

        .camera-actions {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .camera-actions button {
            padding: 8px 12px;
            font-size: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .modal-header h2 {
            font-size: 1.8em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .close-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .close-button:hover {
            background: rgba(255,255,255,0.1);
        }

        .form-section {
            margin-bottom: 25px;
        }

        .form-section h3 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #a8dadc;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 5px;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            color: white;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255,255,255,0.15);
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }

        .help-text {
            font-size: 0.8em;
            opacity: 0.7;
            margin-top: 3px;
        }

        .alert {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.show {
            display: block;
        }

        .alert.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4caf50;
        }

        .alert.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
        }

        .alert.warning {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #ff9800;
        }

        .auth-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
        }

        .auth-modal.show {
            display: block;
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .collapsible:before {
            content: '‚ñº';
            font-size: 0.8em;
            transition: transform 0.3s;
        }

        .collapsible.collapsed:before {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 1000px;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìπ RTSP Video Streaming Server</h1>
            <p>Real-time Camera Management & Monitoring</p>
        </div>

        <div class="controls">
            <div class="refresh-section">
                <label>
                    <input type="checkbox" id="autoRefresh" checked>
                    Auto Refresh
                </label>
                <select id="refreshInterval">
                    <option value="2000">2s</option>
                    <option value="5000" selected>5s</option>
                    <option value="10000">10s</option>
                    <option value="30000">30s</option>
                    <option value="60000">60s</option>
                </select>
                <button onclick="refreshStatus(true)">üîÑ Refresh Now</button>
            </div>
            
            <div class="stream-section">
                <label>
                    <input type="checkbox" id="allStreamsToggle" onchange="toggleAllStreams()">
                    üì∫ Enable All Streams
                </label>
            </div>
            
            <div class="admin-section">
                <button class="admin-btn" onclick="showAdminAuth()">üîê Admin Mode</button>
                <button class="add-btn" onclick="showAddCamera()" style="display:none" id="addCameraBtn">‚ûï Add Camera</button>
                <button class="config-btn" onclick="showServerConfig()" style="display:none" id="serverConfigBtn">‚öôÔ∏è Server Config</button>
            </div>
        </div>

        <div class="server-status">
            <h2>Server Status</h2>
            <div class="status-grid">
                <div class="status-item">
                    <span class="status-label">Status</span>
                    <span class="status-value" id="serverStatus">Connecting...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Uptime</span>
                    <span class="status-value" id="serverUptime">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Active Cameras</span>
                    <span class="status-value" id="activeCameras">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Total Connections</span>
                    <span class="status-value" id="totalConnections">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Recording</span>
                    <span class="status-value" id="recordingStatus">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">MQTT</span>
                    <span class="status-value" id="mqttStatus">-</span>
                </div>
            </div>
        </div>

        <div id="alert" class="alert"></div>

        <h2 style="margin-bottom: 20px;">üì∑ Camera Streams</h2>
        <div class="cameras-grid" id="camerasGrid">
            <!-- Camera tiles will be inserted here -->
        </div>
    </div>

    <!-- Camera Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Camera Configuration</h2>
                <button class="close-button" onclick="closeEditModal()">‚úï</button>
            </div>
            
            <form id="cameraForm">
                <input type="hidden" id="editingCameraId">
                
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">Basic Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Camera ID*</label>
                                <input type="text" id="cameraId" name="cameraId" required>
                                <span class="help-text">Unique identifier for this camera</span>
                            </div>
                            <div class="form-group">
                                <label>Enabled</label>
                                <select id="enabled" name="enabled">
                                    <option value="true">Yes</option>
                                    <option value="false">No</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Path*</label>
                                <input type="text" id="path" name="path" placeholder="/cam1" required>
                                <span class="help-text">URL path for this camera</span>
                            </div>
                            <div class="form-group">
                                <label>RTSP/HTTP URL*</label>
                                <input type="text" id="url" name="url" placeholder="rtsp://user:pass@ip:port/stream" required>
                                <span class="help-text">Camera stream URL</span>
                            </div>
                            <div class="form-group">
                                <label>Transport</label>
                                <select id="transport" name="transport">
                                    <option value="tcp">TCP</option>
                                    <option value="udp">UDP</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Reconnect Interval (s)</label>
                                <input type="number" id="reconnect_interval" name="reconnect_interval" value="5" min="1">
                            </div>
                            <div class="form-group">
                                <label>Token (optional)</label>
                                <input type="text" id="token" name="token" placeholder="Optional auth token">
                                <span class="help-text">Token for WebSocket auth</span>
                            </div>
                            <div class="form-group">
                                <label>Max Recording Age</label>
                                <input type="text" id="max_recording_age" name="max_recording_age" placeholder="7d">
                                <span class="help-text">e.g., 10m, 5h, 7d</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="collapsible collapsed" onclick="toggleSection(this)">MQTT Settings</h3>
                    <div class="collapsible-content collapsed">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Publish Interval (s)</label>
                                <input type="number" id="mqtt_publish_interval" name="mqtt_publish_interval" value="0" min="0">
                                <span class="help-text">0 = every frame, empty = disabled</span>
                            </div>
                            <div class="form-group">
                                <label>Topic Name</label>
                                <input type="text" id="mqtt_topic_name" name="mqtt_topic_name" placeholder="surveillance/cameras/cam1/image">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="collapsible collapsed" onclick="toggleSection(this)">FFmpeg Settings</h3>
                    <div class="collapsible-content collapsed">
                        <div class="form-group" style="grid-column: 1 / -1; margin-bottom: 20px;">
                            <label style="color: #ff6b6b; font-weight: bold;">Custom FFmpeg Command (Override)</label>
                            <textarea id="ffmpeg_command" name="ffmpeg_command" rows="3" placeholder="Example: -rtsp_transport tcp -i {input} -f mjpeg -vf fps=5 -an -" style="width: 100%; font-family: monospace; font-size: 14px;"></textarea>
                            <span class="help-text" style="color: #ff9800; font-weight: bold;">‚ö†Ô∏è WARNING: This will override ALL other FFmpeg settings below when specified. Use {input} as placeholder for the camera URL.</span>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Quality (1-100)</label>
                                <input type="number" id="ffmpeg_quality" name="ffmpeg_quality" min="1" max="100" placeholder="75">
                            </div>
                            <div class="form-group">
                                <label>Use Wallclock as Timestamps</label>
                                <select id="ffmpeg_use_wallclock_as_timestamps" name="ffmpeg_use_wallclock_as_timestamps">
                                    <option value="">Default</option>
                                    <option value="true" selected>True</option>
                                    <option value="false">False</option>
                                </select>
                                <span class="help-text">Use system time for timestamps (recommended)</span>
                            </div>
                            <div class="form-group">
                                <label>Scale</label>
                                <input type="text" id="ffmpeg_scale" name="ffmpeg_scale" placeholder="640:-1">
                                <span class="help-text">Width:Height (-1 keeps ratio)</span>
                            </div>
                            <div class="form-group">
                                <label>Output Framerate</label>
                                <input type="number" id="ffmpeg_output_framerate" name="ffmpeg_output_framerate" min="0" placeholder="5">
                            </div>
                            <div class="form-group">
                                <label>Video Bitrate</label>
                                <input type="text" id="ffmpeg_video_bitrate" name="ffmpeg_video_bitrate" placeholder="200k">
                            </div>
                            <div class="form-group">
                                <label>RTSP Buffer Size</label>
                                <input type="number" id="ffmpeg_rtbufsize" name="ffmpeg_rtbufsize" placeholder="65536">
                            </div>
                            <div class="form-group">
                                <label>Log stderr</label>
                                <select id="ffmpeg_log_stderr" name="ffmpeg_log_stderr">
                                    <option value="">None</option>
                                    <option value="file">File</option>
                                    <option value="console">Console</option>
                                    <option value="both">Both</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Data Timeout (seconds)</label>
                                <input type="number" id="ffmpeg_data_timeout_secs" name="ffmpeg_data_timeout_secs" placeholder="60" min="1">
                                <span class="help-text">Restart FFmpeg if no data received for this many seconds (default: 60)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3 class="collapsible collapsed" onclick="toggleSection(this)">Advanced Options</h3>
                    <div class="collapsible-content collapsed">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>FFmpeg Flags</label>
                                <input type="text" id="ffmpeg_fflags" name="ffmpeg_fflags" placeholder="+nobuffer+discardcorrupt">
                            </div>
                            <div class="form-group">
                                <label>Codec Flags</label>
                                <input type="text" id="ffmpeg_flags" name="ffmpeg_flags" placeholder="low_delay">
                            </div>
                            <div class="form-group">
                                <label>AVIO Flags</label>
                                <input type="text" id="ffmpeg_avioflags" name="ffmpeg_avioflags" placeholder="direct">
                            </div>
                            <div class="form-group">
                                <label>FPS Mode</label>
                                <select id="ffmpeg_fps_mode" name="ffmpeg_fps_mode">
                                    <option value="">Default</option>
                                    <option value="cfr">CFR (Constant)</option>
                                    <option value="vfr">VFR (Variable)</option>
                                    <option value="passthrough">Passthrough</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="form-actions">
                    <button type="button" onclick="closeEditModal()">Cancel</button>
                    <button type="submit">Save Camera</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal">
        <h3>Admin Authentication</h3>
        <div class="form-group" style="margin: 20px 0;">
            <label>Admin Token</label>
            <input type="password" id="adminToken" placeholder="Enter admin token">
        </div>
        <div class="form-actions">
            <button onclick="closeAuthModal()">Cancel</button>
            <button onclick="authenticateAdmin()">Authenticate</button>
        </div>
    </div>

    <!-- Server Config Modal -->
    <div id="serverConfigModal" class="modal">
        <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>Server Configuration</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="toggleConfigView()" id="configViewToggle" style="background: #3498db; padding: 5px 10px; font-size: 12px;">üìù Switch to JSON</button>
                    <button class="close-button" onclick="closeServerConfigModal()">‚úï</button>
                </div>
            </div>
            
            <form id="serverConfigForm" style="margin: 20px 0;">
                <p style="color: #ddd; margin-bottom: 20px;">
                    Configure server settings. Changes will be saved to the config file.
                    <strong>Note:</strong> Some changes may require a server restart to take effect.
                </p>

                <!-- Server Section -->
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">üñ•Ô∏è Server Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Host Address</label>
                                <input type="text" id="config_server_host" placeholder="0.0.0.0">
                                <span class="help-text">IP address to bind the server to (0.0.0.0 for all interfaces)</span>
                            </div>
                            <div class="form-group">
                                <label>Port</label>
                                <input type="number" id="config_server_port" placeholder="8080" min="1" max="65535">
                                <span class="help-text">TCP port for the web server</span>
                            </div>
                            <div class="form-group">
                                <label>CORS Origin</label>
                                <input type="text" id="config_server_cors_allow_origin" placeholder="*">
                                <span class="help-text">Allowed CORS origin (* for all, or specific domain)</span>
                            </div>
                            <div class="form-group">
                                <label>Admin Token</label>
                                <input type="password" id="config_server_admin_token" placeholder="Enter secure token">
                                <span class="help-text">Token required for admin dashboard access</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TLS Section -->
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">üîí TLS/SSL Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Enable TLS/SSL</label>
                                <select id="config_server_tls_enabled">
                                    <option value="false">Disabled</option>
                                    <option value="true">Enabled</option>
                                </select>
                                <span class="help-text">Enable HTTPS and secure WebSocket connections</span>
                            </div>
                            <div class="form-group">
                                <label>Certificate Path</label>
                                <input type="text" id="config_server_tls_cert_path" placeholder="certs/server.crt">
                                <span class="help-text">Path to SSL certificate file</span>
                            </div>
                            <div class="form-group">
                                <label>Private Key Path</label>
                                <input type="text" id="config_server_tls_key_path" placeholder="certs/server.key">
                                <span class="help-text">Path to SSL private key file</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- MQTT Section -->
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">üì° MQTT Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Enable MQTT</label>
                                <select id="config_mqtt_enabled">
                                    <option value="false">Disabled</option>
                                    <option value="true">Enabled</option>
                                </select>
                                <span class="help-text">Enable MQTT message publishing</span>
                            </div>
                            <div class="form-group">
                                <label>Broker URL</label>
                                <input type="text" id="config_mqtt_broker_url" placeholder="mqtt://192.168.1.4:1883">
                                <span class="help-text">MQTT broker connection URL</span>
                            </div>
                            <div class="form-group">
                                <label>Client ID</label>
                                <input type="text" id="config_mqtt_client_id" placeholder="videoserver-01">
                                <span class="help-text">Unique MQTT client identifier</span>
                            </div>
                            <div class="form-group">
                                <label>Base Topic</label>
                                <input type="text" id="config_mqtt_base_topic" placeholder="Videoserver">
                                <span class="help-text">Base topic prefix for all MQTT messages</span>
                            </div>
                            <div class="form-group">
                                <label>Quality of Service</label>
                                <select id="config_mqtt_qos">
                                    <option value="0">0 - At most once</option>
                                    <option value="1">1 - At least once</option>
                                    <option value="2">2 - Exactly once</option>
                                </select>
                                <span class="help-text">MQTT message delivery guarantee</span>
                            </div>
                            <div class="form-group">
                                <label>Retain Messages</label>
                                <select id="config_mqtt_retain">
                                    <option value="false">No</option>
                                    <option value="true">Yes</option>
                                </select>
                                <span class="help-text">Whether MQTT messages should be retained by broker</span>
                            </div>
                            <div class="form-group">
                                <label>Keep Alive (seconds)</label>
                                <input type="number" id="config_mqtt_keep_alive_secs" placeholder="60" min="1">
                                <span class="help-text">MQTT keep-alive interval</span>
                            </div>
                            <div class="form-group">
                                <label>Publish Interval (seconds)</label>
                                <input type="number" id="config_mqtt_publish_interval_secs" placeholder="1" min="1">
                                <span class="help-text">How often to publish status updates</span>
                            </div>
                            <div class="form-group">
                                <label>Publish Picture Arrival</label>
                                <select id="config_mqtt_publish_picture_arrival">
                                    <option value="true">Yes</option>
                                    <option value="false">No</option>
                                </select>
                                <span class="help-text">Publish messages when new frames arrive</span>
                            </div>
                            <div class="form-group">
                                <label>Max Packet Size (bytes)</label>
                                <input type="number" id="config_mqtt_max_packet_size" placeholder="268435456" min="1024">
                                <span class="help-text">Maximum MQTT packet size</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recording Section -->
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">üé• Recording Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Enable Recording</label>
                                <select id="config_recording_enabled">
                                    <option value="false">Disabled</option>
                                    <option value="true">Enabled</option>
                                </select>
                                <span class="help-text">Enable video recording functionality</span>
                            </div>
                            <div class="form-group">
                                <label>Database Path</label>
                                <input type="text" id="config_recording_database_path" placeholder="recordings">
                                <span class="help-text">Directory for recording database storage</span>
                            </div>
                            <div class="form-group">
                                <label>Max Frame Size (bytes)</label>
                                <input type="number" id="config_recording_max_frame_size" placeholder="10485760" min="1024">
                                <span class="help-text">Maximum size for a single frame (10MB default)</span>
                            </div>
                            <div class="form-group">
                                <label>Max Recording Age</label>
                                <input type="text" id="config_recording_max_recording_age" placeholder="7d">
                                <span class="help-text">Auto-delete recordings older than this (e.g., 7d, 24h, 30m)</span>
                            </div>
                            <div class="form-group">
                                <label>Cleanup Interval (hours)</label>
                                <input type="number" id="config_recording_cleanup_interval_hours" placeholder="1" min="1">
                                <span class="help-text">How often to run cleanup of old recordings</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Transcoding Section -->
                <div class="form-section">
                    <h3 class="collapsible" onclick="toggleSection(this)">üé¨ Transcoding Settings</h3>
                    <div class="collapsible-content">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Output Format</label>
                                <select id="config_transcoding_output_format">
                                    <option value="mjpeg">MJPEG</option>
                                    <option value="h264">H.264</option>
                                    <option value="webm">WebM</option>
                                </select>
                                <span class="help-text">Video output format for streaming</span>
                            </div>
                            <div class="form-group">
                                <label>Capture Framerate</label>
                                <input type="number" id="config_transcoding_capture_framerate" placeholder="5" min="0" step="0.1">
                                <span class="help-text">Input capture rate (0 = max available from camera)</span>
                            </div>
                            <div class="form-group">
                                <label>Output Framerate</label>
                                <input type="number" id="config_transcoding_output_framerate" placeholder="0" min="0" step="0.1">
                                <span class="help-text">Output streaming rate (0 = same as input)</span>
                            </div>
                            <div class="form-group">
                                <label>Channel Buffer Size</label>
                                <input type="number" id="config_transcoding_channel_buffer_size" placeholder="50" min="1">
                                <span class="help-text">Frame buffer size (higher = more memory, smoother)</span>
                            </div>
                            <div class="form-group">
                                <label>Debug Capture</label>
                                <select id="config_transcoding_debug_capture">
                                    <option value="false">Disabled</option>
                                    <option value="true">Enabled</option>
                                </select>
                                <span class="help-text">Show capture rate debug information</span>
                            </div>
                            <div class="form-group">
                                <label>Debug Duplicate Frames</label>
                                <select id="config_transcoding_debug_duplicate_frames">
                                    <option value="false">Disabled</option>
                                    <option value="true">Enabled</option>
                                </select>
                                <span class="help-text">Show duplicate frame detection debug info</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: flex-end; padding-top: 20px; border-top: 1px solid #444;">
                    <button type="button" onclick="resetServerConfig()" style="background: #666;">Reset to Original</button>
                    <button type="button" onclick="exportServerConfig()" style="background: #3498db;">Export JSON</button>
                    <button type="button" onclick="saveServerConfig()" style="background: #27ae60;">Save Configuration</button>
                </div>
            </form>

            <!-- JSON Editor View -->
            <div id="serverConfigJson" style="margin: 20px 0; display: none;">
                <p style="color: #ddd; margin-bottom: 15px;">
                    Edit the server configuration directly as JSON. Changes will be saved to the config file.
                    <strong>Note:</strong> Some changes may require a server restart to take effect.
                </p>
                
                <textarea id="serverConfigEditor" 
                          style="width: 100%; height: 400px; background: #1a1a1a; color: #f0f0f0; border: 1px solid #444; border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.4; resize: vertical;"
                          placeholder="Loading configuration..."></textarea>
                
                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="resetServerConfigJson()" style="background: #666;">Reset</button>
                    <button onclick="validateServerConfig()" style="background: #f39c12;">Validate JSON</button>
                    <button onclick="saveServerConfigJson()" style="background: #27ae60;">Save Configuration</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let refreshTimer;
        let currentCameras = [];
        let isManualRefresh = false;
        let isAdminMode = false;
        let isRefreshing = false; // Prevent overlapping refresh calls
        
        // Token Storage:
        // - Admin token: Stored in localStorage as 'adminToken'  
        // - Camera tokens: Stored in localStorage as 'cameraTokens' (JSON object)
        // - Session timestamp: Stored as 'adminTokenTimestamp' for auto-logout
        // - Not using cookies for compatibility and explicit control
        // - Tokens are cleared when admin mode is disabled or session expires
        let adminToken = localStorage.getItem('adminToken') || '';
        // Get base path by removing '/dashboard' from the end of the pathname
        const pathname = window.location.pathname;
        const basePath = pathname.endsWith('/dashboard') 
            ? pathname.slice(0, -'/dashboard'.length) 
            : pathname.replace(/\/dashboard$/, '');
        
        // Log base path for debugging proxy setups
        console.log('Dashboard loaded from:', pathname);
        console.log('Using base path for API calls:', basePath || '(root)');
        
        // Session timeout: 4 hours (in milliseconds)
        const SESSION_TIMEOUT = 4 * 60 * 60 * 1000;
        
        // Check token expiration on load
        function checkTokenExpiration() {
            const tokenTimestamp = localStorage.getItem('adminTokenTimestamp');
            if (adminToken && tokenTimestamp) {
                const now = Date.now();
                const tokenAge = now - parseInt(tokenTimestamp);
                if (tokenAge > SESSION_TIMEOUT) {
                    // Token expired
                    adminToken = '';
                    localStorage.removeItem('adminToken');
                    localStorage.removeItem('adminTokenTimestamp');
                    showAlert('Admin session expired. Please authenticate again.', 'warning');
                }
            }
        }
        
        // Storage for camera tokens
        const cameraTokens = {};
        
        // Load camera tokens from localStorage
        const storedCameraTokens = localStorage.getItem('cameraTokens');
        if (storedCameraTokens) {
            try {
                const tokens = JSON.parse(storedCameraTokens);
                Object.assign(cameraTokens, tokens);
            } catch (e) {
                console.warn('Failed to parse stored camera tokens:', e);
            }
        }

        // Check token expiration first
        checkTokenExpiration();
        
        // Check if admin token is valid on load
        if (adminToken) {
            checkAdminAccess();
        }

        async function checkAdminAccess() {
            try {
                // Test admin access by trying to get a camera config (using cam1 as test)
                const response = await fetch(`${basePath}/api/admin/cameras/cam1`, {
                    headers: {
                        'Authorization': `Bearer ${adminToken}`
                    }
                });
                
                if (response.ok) {
                    enableAdminMode();
                } else if (response.status === 401) {
                    adminToken = '';
                    localStorage.removeItem('adminToken');
                    localStorage.removeItem('adminTokenTimestamp');
                }
            } catch (error) {
                console.error('Error checking admin access:', error);
            }
        }

        function showAdminAuth() {
            document.getElementById('authModal').classList.add('show');
        }

        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('show');
        }

        async function authenticateAdmin() {
            const token = document.getElementById('adminToken').value;
            
            try {
                // Test admin access by trying to get a camera config (using cam1 as test)
                const response = await fetch(`${basePath}/api/admin/cameras/cam1`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (response.ok) {
                    adminToken = token;
                    localStorage.setItem('adminToken', token);
                    localStorage.setItem('adminTokenTimestamp', Date.now().toString());
                    enableAdminMode();
                    closeAuthModal();
                    showAlert('Admin mode enabled', 'success');
                } else {
                    showAlert('Invalid admin token', 'error');
                }
            } catch (error) {
                showAlert('Authentication failed', 'error');
            }
        }

        function enableAdminMode() {
            isAdminMode = true;
            document.getElementById('addCameraBtn').style.display = 'inline-block';
            document.getElementById('serverConfigBtn').style.display = 'inline-block';
            const adminBtn = document.querySelector('.admin-btn');
            adminBtn.textContent = '‚úì Admin Mode (Click to Disable)';
            adminBtn.style.background = 'linear-gradient(135deg, #4caf50 0%, #8bc34a 100%)';
            adminBtn.onclick = disableAdminMode;
            // Refresh camera list to show admin buttons (edit/delete)
            refreshStatus(true);
        }

        function disableAdminMode() {
            isAdminMode = false;
            adminToken = '';
            localStorage.removeItem('adminToken');
            localStorage.removeItem('adminTokenTimestamp');
            
            // Hide admin buttons
            document.getElementById('addCameraBtn').style.display = 'none';
            document.getElementById('serverConfigBtn').style.display = 'none';
            
            // Reset admin button
            const adminBtn = document.querySelector('.admin-btn');
            adminBtn.textContent = 'üîê Admin Mode';
            adminBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            adminBtn.onclick = showAdminAuth;
            
            // Refresh camera list to hide admin buttons (edit/delete)
            refreshStatus(true);
            
            showAlert('Admin mode disabled', 'info');
        }

        function showAlert(message, type = 'info') {
            const alert = document.getElementById('alert');
            alert.className = `alert ${type} show`;
            alert.textContent = message;
            
            setTimeout(() => {
                alert.classList.remove('show');
            }, 5000);
        }

        function toggleSection(element) {
            element.classList.toggle('collapsed');
            element.nextElementSibling.classList.toggle('collapsed');
        }

        function showAddCamera() {
            if (!isAdminMode) {
                showAdminAuth();
                return;
            }
            
            document.getElementById('editingCameraId').value = '';
            document.getElementById('cameraForm').reset();
            document.getElementById('cameraId').disabled = false;
            document.querySelector('.modal-header h2').textContent = 'Add New Camera';
            document.getElementById('editModal').classList.add('active');
        }

        function showEditCamera(cameraId) {
            if (!isAdminMode) {
                showAdminAuth();
                return;
            }
            
            fetch(`${basePath}/api/admin/cameras/${cameraId}`, {
                headers: {
                    'Authorization': `Bearer ${adminToken}`
                }
            })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        populateForm({ camera_id: cameraId, config: data.data });
                        document.getElementById('editingCameraId').value = cameraId;
                        document.getElementById('cameraId').value = cameraId;
                        document.getElementById('cameraId').disabled = true;
                        document.querySelector('.modal-header h2').textContent = 'Edit Camera';
                        document.getElementById('editModal').classList.add('active');
                    } else {
                        showAlert('Failed to load camera configuration', 'error');
                    }
                })
                .catch(error => {
                    console.error('Error loading camera config:', error);
                    showAlert('Failed to load camera configuration', 'error');
                });
        }

        function populateForm(camera) {
            const config = camera.config;
            
            // Basic settings
            document.getElementById('enabled').value = config.enabled !== false ? 'true' : 'false';
            document.getElementById('path').value = config.path || '';
            document.getElementById('url').value = config.url || '';
            document.getElementById('transport').value = config.transport || 'tcp';
            document.getElementById('reconnect_interval').value = config.reconnect_interval || 5;
            document.getElementById('token').value = config.token || '';
            document.getElementById('max_recording_age').value = config.max_recording_age || '';
            
            // MQTT settings
            if (config.mqtt) {
                document.getElementById('mqtt_publish_interval').value = config.mqtt.publish_interval || 0;
                document.getElementById('mqtt_topic_name').value = config.mqtt.topic_name || '';
            }
            
            // FFmpeg settings
            if (config.ffmpeg) {
                document.getElementById('ffmpeg_command').value = config.ffmpeg.command || '';
                document.getElementById('ffmpeg_quality').value = config.ffmpeg.quality || '';
                document.getElementById('ffmpeg_use_wallclock_as_timestamps').value = config.ffmpeg.use_wallclock_as_timestamps !== undefined && config.ffmpeg.use_wallclock_as_timestamps !== null ? config.ffmpeg.use_wallclock_as_timestamps.toString() : 'true';
                document.getElementById('ffmpeg_scale').value = config.ffmpeg.scale || '';
                document.getElementById('ffmpeg_output_framerate').value = config.ffmpeg.output_framerate || '';
                document.getElementById('ffmpeg_video_bitrate').value = config.ffmpeg.video_bitrate || '';
                document.getElementById('ffmpeg_rtbufsize').value = config.ffmpeg.rtbufsize || '';
                document.getElementById('ffmpeg_log_stderr').value = config.ffmpeg.log_stderr || '';
                document.getElementById('ffmpeg_fflags').value = config.ffmpeg.fflags || '';
                document.getElementById('ffmpeg_flags').value = config.ffmpeg.flags || '';
                document.getElementById('ffmpeg_avioflags').value = config.ffmpeg.avioflags || '';
                document.getElementById('ffmpeg_fps_mode').value = config.ffmpeg.fps_mode || '';
                document.getElementById('ffmpeg_data_timeout_secs').value = config.ffmpeg.data_timeout_secs || '';
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('active');
        }

        let originalServerConfig = {};

        async function showServerConfig() {
            if (!isAdminMode) {
                showAdminAuth();
                return;
            }
            
            try {
                const response = await fetch(`${basePath}/api/admin/config`, {
                    headers: {
                        'Authorization': `Bearer ${adminToken}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === 'success') {
                        originalServerConfig = data.data;
                        populateServerConfigForm(data.data);
                        // Also populate the JSON editor with the current config
                        const configJson = JSON.stringify(data.data, null, 2);
                        document.getElementById('serverConfigEditor').value = configJson;
                        document.getElementById('serverConfigModal').classList.add('active');
                    } else {
                        showAlert('Failed to load server configuration', 'error');
                    }
                } else {
                    showAlert('Unauthorized or failed to load configuration', 'error');
                }
            } catch (error) {
                showAlert(`Error loading configuration: ${error.message}`, 'error');
            }
        }

        function populateServerConfigForm(config) {
            // Server settings
            document.getElementById('config_server_host').value = config.server?.host || '';
            document.getElementById('config_server_port').value = config.server?.port || '';
            document.getElementById('config_server_cors_allow_origin').value = config.server?.cors_allow_origin || '';
            document.getElementById('config_server_admin_token').value = config.server?.admin_token || '';
            
            // TLS settings
            document.getElementById('config_server_tls_enabled').value = (config.server?.tls?.enabled || false).toString();
            document.getElementById('config_server_tls_cert_path').value = config.server?.tls?.cert_path || '';
            document.getElementById('config_server_tls_key_path').value = config.server?.tls?.key_path || '';
            
            // MQTT settings
            document.getElementById('config_mqtt_enabled').value = (config.mqtt?.enabled || false).toString();
            document.getElementById('config_mqtt_broker_url').value = config.mqtt?.broker_url || '';
            document.getElementById('config_mqtt_client_id').value = config.mqtt?.client_id || '';
            document.getElementById('config_mqtt_base_topic').value = config.mqtt?.base_topic || '';
            document.getElementById('config_mqtt_qos').value = (config.mqtt?.qos || 0).toString();
            document.getElementById('config_mqtt_retain').value = (config.mqtt?.retain || false).toString();
            document.getElementById('config_mqtt_keep_alive_secs').value = config.mqtt?.keep_alive_secs || '';
            document.getElementById('config_mqtt_publish_interval_secs').value = config.mqtt?.publish_interval_secs || '';
            document.getElementById('config_mqtt_publish_picture_arrival').value = (config.mqtt?.publish_picture_arrival !== undefined ? config.mqtt.publish_picture_arrival : true).toString();
            document.getElementById('config_mqtt_max_packet_size').value = config.mqtt?.max_packet_size || '';
            
            // Recording settings
            document.getElementById('config_recording_enabled').value = (config.recording?.enabled || false).toString();
            document.getElementById('config_recording_database_path').value = config.recording?.database_path || '';
            document.getElementById('config_recording_max_frame_size').value = config.recording?.max_frame_size || '';
            document.getElementById('config_recording_max_recording_age').value = config.recording?.max_recording_age || '';
            document.getElementById('config_recording_cleanup_interval_hours').value = config.recording?.cleanup_interval_hours || '';
            
            // Transcoding settings
            document.getElementById('config_transcoding_output_format').value = config.transcoding?.output_format || 'mjpeg';
            document.getElementById('config_transcoding_capture_framerate').value = config.transcoding?.capture_framerate || '';
            document.getElementById('config_transcoding_output_framerate').value = config.transcoding?.output_framerate || '';
            document.getElementById('config_transcoding_channel_buffer_size').value = config.transcoding?.channel_buffer_size || '';
            document.getElementById('config_transcoding_debug_capture').value = (config.transcoding?.debug_capture || false).toString();
            document.getElementById('config_transcoding_debug_duplicate_frames').value = (config.transcoding?.debug_duplicate_frames || false).toString();
        }

        function collectServerConfigFromForm() {
            return {
                server: {
                    host: document.getElementById('config_server_host').value || "0.0.0.0",
                    port: parseInt(document.getElementById('config_server_port').value) || 8080,
                    cors_allow_origin: document.getElementById('config_server_cors_allow_origin').value || "*",
                    admin_token: document.getElementById('config_server_admin_token').value || "",
                    tls: {
                        enabled: document.getElementById('config_server_tls_enabled').value === 'true',
                        cert_path: document.getElementById('config_server_tls_cert_path').value || "certs/server.crt",
                        key_path: document.getElementById('config_server_tls_key_path').value || "certs/server.key"
                    }
                },
                mqtt: {
                    enabled: document.getElementById('config_mqtt_enabled').value === 'true',
                    broker_url: document.getElementById('config_mqtt_broker_url').value || "",
                    client_id: document.getElementById('config_mqtt_client_id').value || "",
                    base_topic: document.getElementById('config_mqtt_base_topic').value || "",
                    qos: parseInt(document.getElementById('config_mqtt_qos').value) || 0,
                    retain: document.getElementById('config_mqtt_retain').value === 'true',
                    keep_alive_secs: parseInt(document.getElementById('config_mqtt_keep_alive_secs').value) || 60,
                    publish_interval_secs: parseInt(document.getElementById('config_mqtt_publish_interval_secs').value) || 1,
                    publish_picture_arrival: document.getElementById('config_mqtt_publish_picture_arrival').value === 'true',
                    max_packet_size: parseInt(document.getElementById('config_mqtt_max_packet_size').value) || 268435456
                },
                recording: {
                    enabled: document.getElementById('config_recording_enabled').value === 'true',
                    database_path: document.getElementById('config_recording_database_path').value || "recordings",
                    max_frame_size: parseInt(document.getElementById('config_recording_max_frame_size').value) || 10485760,
                    max_recording_age: document.getElementById('config_recording_max_recording_age').value || "7d",
                    cleanup_interval_hours: parseInt(document.getElementById('config_recording_cleanup_interval_hours').value) || 1
                },
                transcoding: {
                    output_format: document.getElementById('config_transcoding_output_format').value || "mjpeg",
                    capture_framerate: parseFloat(document.getElementById('config_transcoding_capture_framerate').value) || 5,
                    output_framerate: parseFloat(document.getElementById('config_transcoding_output_framerate').value) || 0,
                    channel_buffer_size: parseInt(document.getElementById('config_transcoding_channel_buffer_size').value) || 50,
                    debug_capture: document.getElementById('config_transcoding_debug_capture').value === 'true',
                    debug_duplicate_frames: document.getElementById('config_transcoding_debug_duplicate_frames').value === 'true'
                }
            };
        }

        function closeServerConfigModal() {
            document.getElementById('serverConfigModal').classList.remove('active');
        }

        function resetServerConfig() {
            populateServerConfigForm(originalServerConfig);
            showAlert('Configuration reset to original values', 'info');
        }

        function exportServerConfig() {
            const config = collectServerConfigFromForm();
            const configJson = JSON.stringify(config, null, 2);
            
            // Create download link
            const blob = new Blob([configJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert('Configuration exported as config.json', 'success');
        }

        async function saveServerConfig() {
            try {
                const config = collectServerConfigFromForm();
                
                const response = await fetch(`${basePath}/api/admin/config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === 'success') {
                        originalServerConfig = config; // Update original to new saved version
                        showAlert('Server configuration saved successfully! ' + (data.data.note || ''), 'success');
                        closeServerConfigModal();
                    } else {
                        showAlert(`Failed to save: ${data.message}`, 'error');
                    }
                } else {
                    const errorData = await response.text();
                    showAlert(`Error saving configuration: ${errorData}`, 'error');
                }
            } catch (error) {
                showAlert(`Error saving configuration: ${error.message}`, 'error');
            }
        }

        // Toggle between form view and JSON view
        function toggleConfigView() {
            const formView = document.getElementById('serverConfigForm');
            const jsonView = document.getElementById('serverConfigJson');
            const toggleBtn = document.getElementById('configViewToggle');
            
            if (formView.style.display === 'none') {
                // Switch to form view
                formView.style.display = 'block';
                jsonView.style.display = 'none';
                toggleBtn.textContent = 'üìù Switch to JSON';
                
                // Sync JSON to form when switching to form view
                try {
                    const jsonText = document.getElementById('serverConfigEditor').value;
                    if (jsonText.trim()) {
                        const config = JSON.parse(jsonText);
                        populateServerConfigForm(config);
                    }
                } catch (e) {
                    showAlert('Invalid JSON detected - keeping form data unchanged', 'warning');
                }
            } else {
                // Switch to JSON view
                formView.style.display = 'none';
                jsonView.style.display = 'block';
                toggleBtn.textContent = 'üìÑ Switch to Form';
                
                // Sync form to JSON when switching to JSON view
                const config = collectServerConfigFromForm();
                const configJson = JSON.stringify(config, null, 2);
                document.getElementById('serverConfigEditor').value = configJson;
            }
        }

        // Reset JSON editor to original configuration
        function resetServerConfigJson() {
            const configJson = JSON.stringify(originalServerConfig, null, 2);
            document.getElementById('serverConfigEditor').value = configJson;
            showAlert('JSON editor reset to original values', 'info');
        }

        // Validate JSON in the editor
        function validateServerConfig() {
            try {
                const jsonText = document.getElementById('serverConfigEditor').value;
                JSON.parse(jsonText);
                showAlert('JSON is valid!', 'success');
            } catch (e) {
                showAlert(`Invalid JSON: ${e.message}`, 'error');
            }
        }

        // Save configuration from JSON editor
        async function saveServerConfigJson() {
            try {
                const jsonText = document.getElementById('serverConfigEditor').value;
                const config = JSON.parse(jsonText);
                
                const response = await fetch(`${basePath}/api/admin/config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(config)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === 'success') {
                        originalServerConfig = config; // Update original to new saved version
                        showAlert('Server configuration saved successfully! ' + (data.data.note || ''), 'success');
                        closeServerConfigModal();
                    } else {
                        showAlert(`Failed to save: ${data.message}`, 'error');
                    }
                } else {
                    const errorData = await response.text();
                    showAlert(`Error saving configuration: ${errorData}`, 'error');
                }
            } catch (error) {
                if (error instanceof SyntaxError) {
                    showAlert(`Invalid JSON: ${error.message}`, 'error');
                } else {
                    showAlert(`Error saving configuration: ${error.message}`, 'error');
                }
            }
        }

        async function deleteCamera(cameraId) {
            if (!isAdminMode) {
                showAdminAuth();
                return;
            }
            
            if (!confirm(`Are you sure you want to delete camera ${cameraId}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${basePath}/api/admin/cameras/${cameraId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${adminToken}`
                    }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`Camera ${cameraId} deleted successfully`, 'success');
                    refreshStatus();
                } else {
                    showAlert(data.error || 'Failed to delete camera', 'error');
                }
            } catch (error) {
                showAlert('Error deleting camera', 'error');
            }
        }

        document.getElementById('cameraForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            const isEditing = document.getElementById('editingCameraId').value;
            const cameraId = isEditing || formData.get('cameraId');
            
            // Build camera config
            const config = {
                enabled: formData.get('enabled') === 'true',
                path: formData.get('path'),
                url: formData.get('url'),
                transport: formData.get('transport'),
                reconnect_interval: parseInt(formData.get('reconnect_interval')),
                token: formData.get('token') || null,
                max_recording_age: formData.get('max_recording_age') || null
            };
            
            // Add MQTT config if configured
            const mqttInterval = formData.get('mqtt_publish_interval');
            const mqttTopic = formData.get('mqtt_topic_name');
            if (mqttInterval || mqttTopic) {
                config.mqtt = {
                    publish_interval: parseInt(mqttInterval) || 0,
                    topic_name: mqttTopic || null
                };
            }
            
            // Add FFmpeg config
            const ffmpegConfig = {};
            const ffmpegFields = [
                'command', 'quality', 'use_wallclock_as_timestamps', 'scale', 'output_framerate', 'video_bitrate',
                'rtbufsize', 'log_stderr', 'fflags', 'flags', 'avioflags', 'fps_mode', 'data_timeout_secs'
            ];
            
            ffmpegFields.forEach(field => {
                const value = formData.get(`ffmpeg_${field}`);
                if (value) {
                    if (field === 'quality' || field === 'output_framerate' || field === 'rtbufsize' || field === 'data_timeout_secs') {
                        ffmpegConfig[field] = parseInt(value);
                    } else if (field === 'use_wallclock_as_timestamps') {
                        ffmpegConfig[field] = value === 'true';
                    } else {
                        ffmpegConfig[field] = value;
                    }
                }
            });
            
            if (Object.keys(ffmpegConfig).length > 0) {
                config.ffmpeg = ffmpegConfig;
            }
            
            try {
                const url = isEditing ? 
                    `${basePath}/api/admin/cameras/${cameraId}` : 
                    `${basePath}/api/admin/cameras`;
                    
                const method = isEditing ? 'PUT' : 'POST';
                const body = isEditing ? config : { camera_id: cameraId, config };
                
                const response = await fetch(url, {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(body)
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    showAlert(`Camera ${cameraId} ${isEditing ? 'updated' : 'created'} successfully`, 'success');
                    closeEditModal();
                    refreshStatus();
                } else {
                    showAlert(data.error || 'Failed to save camera', 'error');
                }
            } catch (error) {
                showAlert('Error saving camera', 'error');
            }
        });

        function hasCameraListChanged(newCameras) {
            if (currentCameras.length !== newCameras.length) {
                return true;
            }
            
            // Check if same cameras exist (by ID)
            const currentIds = new Set(currentCameras.map(c => c.id));
            const newIds = new Set(newCameras.map(c => c.id));
            
            for (const id of newIds) {
                if (!currentIds.has(id)) {
                    return true;
                }
            }
            
            return false;
        }

        async function refreshStatus(forceFullRebuild = false) {
            // Prevent overlapping refresh calls
            if (isRefreshing) {
                console.log('Refresh already in progress, skipping...');
                return;
            }
            
            isRefreshing = true;
            
            try {
                // Load server status and cameras in parallel
                const [statusResponse, camerasResponse] = await Promise.all([
                    fetch(`${basePath}/api/status`),
                    fetch(`${basePath}/api/cameras`)
                ]);
                
                const statusData = await statusResponse.json();
                const camerasData = await camerasResponse.json();
                
                if (statusData.status === 'success' && camerasData.status === 'success') {
                    updateServerStatus(statusData.data, camerasData.data.cameras);
                    
                    const newCameras = camerasData.data.cameras;
                    const needsFullRebuild = forceFullRebuild || hasCameraListChanged(newCameras);
                    
                    if (needsFullRebuild) {
                        // console.log('Performing full camera grid rebuild');
                        await updateCameraGrid(newCameras);
                    } else {
                        // console.log('Performing differential camera update');
                        await updateExistingCameras(newCameras);
                    }
                } else {
                    throw new Error('Failed to load server data');
                }
            } catch (error) {
                console.error('Error fetching status:', error);
                document.getElementById('serverStatus').textContent = 'Offline';
                document.getElementById('serverStatus').style.color = '#f44336';
            } finally {
                // Always reset the refresh flag
                isRefreshing = false;
            }
        }

        function updateServerStatus(statusData, cameras) {
            document.getElementById('serverStatus').textContent = 'Online';
            document.getElementById('serverStatus').style.color = '#4caf50';
            document.getElementById('serverUptime').textContent = formatUptime(statusData.uptime_secs);
            document.getElementById('activeCameras').textContent = statusData.total_cameras;
            document.getElementById('totalConnections').textContent = statusData.total_clients;
            
            // Calculate recording cameras from camera data
            const recordingCameras = cameras.filter(cam => cam.ffmpeg_running).length;
            document.getElementById('recordingStatus').textContent = 
                recordingCameras > 0 ? `${recordingCameras} Active` : 'Inactive';
            
            // MQTT status - assume connected if server is running (could be enhanced later)
            document.getElementById('mqttStatus').textContent = 'Connected';
        }

        async function updateExistingCameras(cameras) {
            currentCameras = cameras; // Update stored cameras
            
            // Update each existing camera tile with new data
            for (const camera of cameras) {
                await updateCameraTile(camera);
            }
            
            // Update master stream checkbox
            setTimeout(updateMasterStreamCheckbox, 100);
        }

        async function updateCameraTile(camera) {
            const requiresToken = camera.token_required === true;
            const isOnline = camera.ffmpeg_running;
            
            // Use specific IDs to update elements
            const statusElement = document.getElementById(`status-${camera.id}`);
            if (statusElement) {
                statusElement.textContent = isOnline ? 'Online' : 'Offline';
            }
            
            const indicatorElement = document.getElementById(`indicator-${camera.id}`);
            if (indicatorElement) {
                indicatorElement.className = `status-indicator ${isOnline ? '' : 'offline'}`;
            }
            
            const fpsElement = document.getElementById(`fps-${camera.id}`);
            if (fpsElement) {
                fpsElement.textContent = camera.capture_fps.toFixed(1);
            }
            
            const clientsElement = document.getElementById(`clients-${camera.id}`);
            if (clientsElement) {
                clientsElement.textContent = camera.clients_connected;
            }
            
            const frameElement = document.getElementById(`frame-${camera.id}`);
            if (frameElement) {
                frameElement.textContent = camera.last_frame_time ? new Date(camera.last_frame_time).toLocaleTimeString() : 'Never';
            }
            
            // Check if embedded stream needs to be stopped due to camera going offline
            const checkbox = document.getElementById(`stream-checkbox-${camera.id}`);
            if (checkbox && checkbox.checked && !isOnline) {
                showAlert(`Camera ${camera.id} went offline - stopping embedded stream`, 'warning');
                checkbox.checked = false;
                toggleEmbeddedStream(camera.id, camera.path, requiresToken);
            }
            
            // Update admin buttons if in admin mode
            const cameraActionsDiv = document.getElementById(`actions-${camera.id}`);
            if (cameraActionsDiv && isAdminMode) {
                // Check if admin buttons already exist
                if (!cameraActionsDiv.querySelector('.delete-btn')) {
                    // Add admin buttons if they don't exist
                    const editBtn = document.createElement('button');
                    editBtn.onclick = () => showEditCamera(camera.id);
                    editBtn.textContent = '‚úèÔ∏è Edit';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.onclick = () => deleteCamera(camera.id);
                    deleteBtn.textContent = 'üóëÔ∏è Delete';
                    
                    cameraActionsDiv.appendChild(editBtn);
                    cameraActionsDiv.appendChild(deleteBtn);
                }
            } else if (cameraActionsDiv && !isAdminMode) {
                // Remove admin buttons if not in admin mode
                const adminButtons = cameraActionsDiv.querySelectorAll('button:not([onclick*="Stream"]):not([onclick*="Control"]):not([onclick*="Recording"])');
                adminButtons.forEach(btn => btn.remove());
            }
            
            // Update recording status (keep existing function)
            updateRecordingStatus(camera.id, camera.path, requiresToken);
        }

        async function updateCameraGrid(cameras) {
            currentCameras = cameras; // Store cameras globally for recording status
            
            // Save current scroll position
            const scrollY = window.scrollY;
            
            const grid = document.getElementById('camerasGrid');
            grid.innerHTML = '';
            
            // Create all camera tiles in parallel with recording data
            const tilePromises = cameras.map(camera => createCameraTileWithRecording(camera));
            const tiles = await Promise.all(tilePromises);
            
            tiles.forEach(tile => {
                grid.appendChild(tile);
            });
            
            // Restore scroll position after DOM update
            setTimeout(() => {
                window.scrollTo(0, scrollY);
                // Update master stream checkbox after tiles are created
                updateMasterStreamCheckbox();
            }, 0);
        }

        async function createCameraTileWithRecording(camera) {
            const requiresToken = camera.token_required === true;
            
            // Fetch recording data in parallel
            let recordingStatus = 'Unknown';
            let recordingActive = false;
            let dbSize = 'Unknown';
            let recordingBtnText = 'üî¥ Start Recording';
            let recordingBtnColor = '#27ae60';
            
            try {
                const headers = { 'Content-Type': 'application/json' };
                
                if (requiresToken) {
                    // Check if we have a saved token for this camera
                    const savedToken = cameraTokens[camera.id];
                    if (savedToken) {
                        headers['Authorization'] = `Bearer ${savedToken}`;
                    }
                }
                
                if (adminToken) {
                    headers['Authorization'] = `Bearer ${adminToken}`;
                }
                
                const [statusResponse, sizeResponse] = await Promise.all([
                    fetch(`${basePath}${camera.path}/control/recording/active`, { headers }),
                    fetch(`${basePath}${camera.path}/control/recording/size`, { headers })
                ]);
                
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    recordingActive = statusData.status === 'success' && statusData.data && statusData.data.active;
                    recordingStatus = recordingActive ? 'Active' : 'Stopped';
                    recordingBtnText = recordingActive ? '‚èπÔ∏è Stop Recording' : 'üî¥ Start Recording';
                    recordingBtnColor = recordingActive ? '#e74c3c' : '#27ae60';
                }
                
                if (sizeResponse.ok) {
                    const sizeData = await sizeResponse.json();
                    if (sizeData.status === 'success' && sizeData.data) {
                        dbSize = formatFileSize(sizeData.data.size_bytes);
                    }
                }
            } catch (error) {
                // Use default values for errors
            }
            
            return createCameraTile(camera, recordingStatus, recordingActive, dbSize, recordingBtnText, recordingBtnColor);
        }

        function createCameraTile(camera, recordingStatus = 'Loading...', recordingActive = false, dbSize = 'Loading...', recordingBtnText = 'üî¥ Recording', recordingBtnColor = '#27ae60') {
            const tile = document.createElement('div');
            tile.className = 'camera-tile';
            
            const isOnline = camera.ffmpeg_running;
            const streamId = `stream-${camera.id}`;
            const requiresToken = camera.token_required === true;
            
            const adminButtons = isAdminMode ? `
                <button onclick="showEditCamera('${camera.id}')">‚úèÔ∏è Edit</button>
                <button class="delete-btn" onclick="deleteCamera('${camera.id}')">üóëÔ∏è Delete</button>
            ` : '';
            
            // Token input section for cameras that require tokens
            const tokenSection = requiresToken ? `
                <div class="camera-token">
                    <div class="info-row">
                        <span class="info-label">üîê Token:</span>
                        <input type="password" id="token-${camera.id}" placeholder="Enter token" 
                               style="width: 120px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;">
                    </div>
                </div>
            ` : '';
            
            tile.innerHTML = `
                <div class="camera-header">
                    <span class="camera-name">${camera.id}</span>
                    <div class="camera-status">
                        <span id="indicator-${camera.id}" class="status-indicator ${isOnline ? '' : 'offline'}"></span>
                        <span id="status-${camera.id}">${isOnline ? 'Online' : 'Offline'}</span>
                    </div>
                </div>
                <div class="camera-preview">
                    <div class="preview-controls">
                        <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; color: white; cursor: pointer;">
                            <input type="checkbox" id="stream-checkbox-${camera.id}" onchange="toggleEmbeddedStream('${camera.id}', '${camera.path}', ${requiresToken})" style="margin: 0;">
                            üì∫ Live Stream
                        </label>
                    </div>
                    <div id="stream-container-${camera.id}" class="stream-container" style="display: none;">
                        <!-- Embedded stream iframe will be inserted here -->
                    </div>
                    <div id="no-preview-${camera.id}" class="no-preview" onclick="toggleStreamPreview('${camera.id}', '${camera.path}')">üì∑ ${camera.path}</div>
                </div>
                <div class="camera-info">
                    <div class="info-row">
                        <span class="info-label">FPS:</span>
                        <span id="fps-${camera.id}">${camera.capture_fps.toFixed(1)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Clients:</span>
                        <span id="clients-${camera.id}">${camera.clients_connected}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Last Frame:</span>
                        <span id="frame-${camera.id}">${camera.last_frame_time ? new Date(camera.last_frame_time).toLocaleTimeString() : 'Never'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Recording:</span>
                        <span id="recording-status-${camera.id}" style="color: ${recordingActive ? '#27ae60' : '#e74c3c'}">${recordingStatus}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">DB Size:</span>
                        <span id="db-size-${camera.id}">${dbSize}</span>
                    </div>
                    ${tokenSection}
                </div>
                <div id="actions-${camera.id}" class="camera-actions">
                    <button onclick="openCameraStream('${camera.id}', '${camera.path}', ${requiresToken})">üîó Stream</button>
                    <button onclick="openCameraControl('${camera.id}', '${camera.path}', ${requiresToken})">üéÆ Control</button>
                    <button id="recording-btn-${camera.id}" onclick="toggleRecording('${camera.id}', '${camera.path}', ${requiresToken})" style="background: ${recordingBtnColor};">${recordingBtnText}</button>
                    ${adminButtons}
                </div>
            `;
            
            // Restore saved token if available
            if (requiresToken && cameraTokens[camera.id]) {
                setTimeout(() => {
                    const tokenInput = document.getElementById(`token-${camera.id}`);
                    if (tokenInput) {
                        tokenInput.value = cameraTokens[camera.id];
                    }
                }, 0);
            }
            
            return tile;
        }

        function openCameraStream(cameraId, cameraPath, requiresToken) {
            let url = `${basePath}${cameraPath}/stream`;
            
            if (requiresToken) {
                const tokenInput = document.getElementById(`token-${cameraId}`);
                if (tokenInput && tokenInput.value.trim()) {
                    const token = tokenInput.value.trim();
                    // Save token for this camera
                    cameraTokens[cameraId] = token;
                    localStorage.setItem('cameraTokens', JSON.stringify(cameraTokens));
                    url += `?token=${encodeURIComponent(token)}`;
                } else {
                    showAlert('Please enter a token for this camera', 'error');
                    return;
                }
            }
            
            window.open(url, '_blank');
        }
        
        function openCameraControl(cameraId, cameraPath, requiresToken) {
            let url = `${basePath}${cameraPath}/control`;
            
            if (requiresToken) {
                const tokenInput = document.getElementById(`token-${cameraId}`);
                if (tokenInput && tokenInput.value.trim()) {
                    const token = tokenInput.value.trim();
                    // Save token for this camera
                    cameraTokens[cameraId] = token;
                    localStorage.setItem('cameraTokens', JSON.stringify(cameraTokens));
                    url += `?token=${encodeURIComponent(token)}`;
                } else {
                    showAlert('Please enter a token for this camera', 'error');
                    return;
                }
            }
            
            window.open(url, '_blank');
        }

        function toggleAllStreams() {
            const masterCheckbox = document.getElementById('allStreamsToggle');
            const isEnabled = masterCheckbox.checked;
            
            if (!currentCameras || currentCameras.length === 0) {
                showAlert('No cameras available', 'warning');
                masterCheckbox.checked = false;
                return;
            }
            
            let missingTokens = [];
            
            // Check for cameras that require tokens but don't have them
            if (isEnabled) {
                for (const camera of currentCameras) {
                    const requiresToken = camera.token_required === true;
                    if (requiresToken) {
                        const tokenInput = document.getElementById(`token-${camera.id}`);
                        if (!tokenInput || !tokenInput.value.trim()) {
                            missingTokens.push(camera.id);
                        }
                    }
                }
                
                if (missingTokens.length > 0) {
                    showAlert(`Please enter tokens for cameras: ${missingTokens.join(', ')}`, 'error');
                    masterCheckbox.checked = false;
                    return;
                }
            }
            
            // Toggle all individual camera stream checkboxes
            for (const camera of currentCameras) {
                const checkbox = document.getElementById(`stream-checkbox-${camera.id}`);
                if (checkbox && checkbox.checked !== isEnabled) {
                    checkbox.checked = isEnabled;
                    const requiresToken = camera.token_required === true;
                    toggleEmbeddedStream(camera.id, camera.path, requiresToken);
                }
            }
            
            const action = isEnabled ? 'enabled' : 'disabled';
            showAlert(`All camera streams ${action}`, 'success');
        }

        function updateMasterStreamCheckbox() {
            if (!currentCameras || currentCameras.length === 0) return;
            
            const masterCheckbox = document.getElementById('allStreamsToggle');
            const individualCheckboxes = currentCameras.map(camera => 
                document.getElementById(`stream-checkbox-${camera.id}`)
            ).filter(cb => cb !== null);
            
            if (individualCheckboxes.length === 0) return;
            
            const allChecked = individualCheckboxes.every(cb => cb.checked);
            const noneChecked = individualCheckboxes.every(cb => !cb.checked);
            
            if (allChecked) {
                masterCheckbox.checked = true;
                masterCheckbox.indeterminate = false;
            } else if (noneChecked) {
                masterCheckbox.checked = false;
                masterCheckbox.indeterminate = false;
            } else {
                masterCheckbox.checked = false;
                masterCheckbox.indeterminate = true;
            }
        }

        function toggleEmbeddedStream(cameraId, cameraPath, requiresToken) {
            const checkbox = document.getElementById(`stream-checkbox-${cameraId}`);
            const streamContainer = document.getElementById(`stream-container-${cameraId}`);
            const noPreview = document.getElementById(`no-preview-${cameraId}`);
            
            if (checkbox.checked) {
                // Start embedded stream
                let streamUrl = `${basePath}${cameraPath}/stream`;
                
                if (requiresToken) {
                    const tokenInput = document.getElementById(`token-${cameraId}`);
                    if (tokenInput && tokenInput.value.trim()) {
                        const token = tokenInput.value.trim();
                        streamUrl += `?token=${encodeURIComponent(token)}`;
                    } else {
                        showAlert('Please enter a token for this camera first', 'error');
                        checkbox.checked = false;
                        return;
                    }
                }
                
                // Create iframe for embedded stream
                const iframe = document.createElement('iframe');
                iframe.src = streamUrl;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.allowFullscreen = true;
                
                streamContainer.innerHTML = '';
                streamContainer.appendChild(iframe);
                streamContainer.style.display = 'block';
                noPreview.style.display = 'none';
                
                console.log(`Started embedded stream for ${cameraId}: ${streamUrl}`);
            } else {
                // Stop embedded stream
                // First, properly dispose of the iframe to stop its JavaScript execution
                const existingIframe = streamContainer.querySelector('iframe');
                if (existingIframe) {
                    // Set src to about:blank to stop the iframe's execution
                    existingIframe.src = 'about:blank';
                    // Remove the iframe from DOM
                    existingIframe.remove();
                }
                streamContainer.innerHTML = '';
                streamContainer.style.display = 'none';
                noPreview.style.display = 'flex';
                
                console.log(`Stopped embedded stream for ${cameraId}`);
            }
            
            // Update master checkbox state
            setTimeout(updateMasterStreamCheckbox, 100);
        }

        function toggleStreamPreview(cameraId, cameraPath) {
            // Open stream in a modal or new window for better viewing
            openCameraStream(cameraId, cameraPath, false); // Preview doesn't require token check
        }

        async function toggleStream(cameraId, cameraPath) {
            // Note: This would require API endpoints to start/stop individual camera streams
            // For now, we'll just refresh the status to show current state
            showAlert('Stream control coming soon - use the streaming server controls for now', 'info');
            setTimeout(refreshStatus, 5000); // Increased delay to reduce CPU usage
        }

        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            const parts = [];
            if (days > 0) parts.push(`${days}d`);
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            
            return parts.join(' ') || '< 1m';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(1) + ' ' + sizes[i];
        }

        function startAutoRefresh() {
            const autoRefresh = document.getElementById('autoRefresh').checked;
            if (autoRefresh) {
                const interval = parseInt(document.getElementById('refreshInterval').value);
                refreshTimer = setInterval(refreshStatus, interval);
            }
        }

        function stopAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }
        }

        document.getElementById('autoRefresh').addEventListener('change', (e) => {
            if (e.target.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
        });

        document.getElementById('refreshInterval').addEventListener('change', () => {
            stopAutoRefresh();
            if (document.getElementById('autoRefresh').checked) {
                startAutoRefresh();
            }
        });

        // Set favicon
        document.getElementById('favicon').href = `${basePath}/static/favicon.ico`;

        // Recording functionality
        async function toggleRecording(cameraId, cameraPath, requiresToken) {
            const headers = {
                'Content-Type': 'application/json'
            };
            
            if (requiresToken) {
                const tokenInput = document.getElementById(`token-${cameraId}`);
                if (tokenInput && tokenInput.value.trim()) {
                    const token = tokenInput.value.trim();
                    headers['Authorization'] = `Bearer ${token}`;
                } else {
                    showAlert('Please enter a token for this camera', 'error');
                    return;
                }
            }
            
            if (adminToken) {
                headers['Authorization'] = `Bearer ${adminToken}`;
            }
            
            try {
                // First check current recording status
                const statusResponse = await fetch(`${basePath}${cameraPath}/control/recording/active`, { headers });
                const statusData = await statusResponse.json();
                
                const isRecording = statusData.status === 'success' && statusData.data && statusData.data.active;
                const action = isRecording ? 'stop' : 'start';
                
                const requestBody = action === 'start' ? JSON.stringify({ reason: 'Manual recording started from dashboard' }) : undefined;
                
                const response = await fetch(`${basePath}${cameraPath}/control/recording/${action}`, {
                    method: 'POST',
                    headers,
                    body: requestBody
                });
                
                if (response.ok) {
                    showAlert(`Recording ${action}ed successfully`, 'success');
                    // Update recording status for this camera
                    updateRecordingStatus(cameraId, cameraPath, requiresToken);
                } else {
                    const errorData = await response.text();
                    showAlert(`Failed to ${action} recording: ${errorData}`, 'error');
                }
            } catch (error) {
                showAlert(`Error controlling recording: ${error.message}`, 'error');
            }
        }
        
        async function updateRecordingStatus(cameraId, cameraPath, requiresToken) {
            const headers = {};
            
            if (requiresToken) {
                const tokenInput = document.getElementById(`token-${cameraId}`);
                if (tokenInput && tokenInput.value.trim()) {
                    const token = tokenInput.value.trim();
                    headers['Authorization'] = `Bearer ${token}`;
                }
            }
            
            if (adminToken) {
                headers['Authorization'] = `Bearer ${adminToken}`;
            }
            
            try {
                // Get recording status
                const statusResponse = await fetch(`${basePath}${cameraPath}/control/recording/active`, { headers });
                const statusData = await statusResponse.json();
                
                const recordingStatusElement = document.getElementById(`recording-status-${cameraId}`);
                const recordingBtnElement = document.getElementById(`recording-btn-${cameraId}`);
                
                const isRecording = statusData.status === 'success' && statusData.data && statusData.data.active;
                
                if (recordingStatusElement) {
                    recordingStatusElement.textContent = isRecording ? 'Active' : 'Stopped';
                    recordingStatusElement.style.color = isRecording ? '#27ae60' : '#e74c3c';
                }
                
                if (recordingBtnElement) {
                    recordingBtnElement.textContent = isRecording ? '‚èπÔ∏è Stop Recording' : 'üî¥ Start Recording';
                    recordingBtnElement.style.background = isRecording ? '#e74c3c' : '#27ae60';
                }
                
                // Get database size
                const dbSizeResponse = await fetch(`${basePath}${cameraPath}/control/recording/size`, { headers });
                const dbSizeData = await dbSizeResponse.json();
                
                const dbSizeElement = document.getElementById(`db-size-${cameraId}`);
                if (dbSizeElement && dbSizeData.status === 'success' && dbSizeData.data) {
                    dbSizeElement.textContent = formatFileSize(dbSizeData.data.size_bytes);
                }
                
            } catch (error) {
                const recordingStatusElement = document.getElementById(`recording-status-${cameraId}`);
                const dbSizeElement = document.getElementById(`db-size-${cameraId}`);
                
                if (recordingStatusElement) {
                    recordingStatusElement.textContent = 'Error';
                    recordingStatusElement.style.color = '#e74c3c';
                }
                
                if (dbSizeElement) {
                    dbSizeElement.textContent = 'Error';
                }
            }
        }
        

        // Initial load
        refreshStatus(true); // Force full rebuild on initial load
        startAutoRefresh();
    </script>
</body>
</html>